/**
 * Core Philosophy: This ruleset enforces a strict Role-Based Access Control (RBAC) model
 * for a medical application. Access to data is determined by a user's role (Admin, Doctor, or Staff),
 * which is verified through dedicated role collections. The default security posture is to deny
 * all access unless a user's role explicitly grants them permission.
 *
 * Data Structure: The data is organized with global catalogs (like doctors, medications) at the
 * top level, and all sensitive patient-specific data (appointments, medical records) nested
 * within a top-level `/patients/{patientId}` collection. User roles are managed in separate
 * top-level collections like `/roles_admin/{userId}` to enable fast, independent authorization checks.
 *
 * Key Security Decisions:
 * - Authorization Independence: Rules rely on fast `exists()` checks against role collections
 *   (e.g., `exists(/.../roles_admin/$(request.auth.uid))`) instead of slow `get()` calls to user
 *   profile documents. This is a critical performance and security feature.
 * - Denormalization for Authorization: Subcollection documents (e.g., appointments, workflows)
 *   contain denormalized fields like `doctorId` or `assignedToDoctorId`. This allows rules to grant
 *   access to specific doctors for specific documents without needing to look up parent documents.
 * - Role-Based Privileges:
 *   - Admins: Have full read/write access to most data and are the only role that can perform
 *     highly destructive actions like deleting patient or doctor records.
 *   - Staff: Have broad access to manage patient data, such as creating new patient records
 *     and scheduling appointments.
 *   - Doctors: Can view their own profile and are granted granular access to patient sub-collection
 *     documents (like appointments or workflows) only when they are explicitly assigned via a
 *     denormalized ID field.
 * - Structural Segregation: Role collections, patient data, and global catalogs are in separate
 *   top-level collections. This separation allows for simpler, more secure, and more performant rules,
 *   especially for list operations.
 * - User Enumeration Prevention: The role collections (`/roles_*`) are not listable by any client,
 *   preventing malicious actors from discovering the UIDs of all admins, doctors, or staff.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the provided userId.
     * Used to verify document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the document being accessed already exists.
     * CRITICAL for all update and delete operations to prevent acting on non-existent data.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Checks if the requesting user has an 'Admin' role.
     * Roles are stored in a dedicated collection for fast 'exists' checks.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Checks if the requesting user has a 'Doctor' role.
     */
    function isDoctor() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_doctor/$(request.auth.uid));
    }

    /**
     * Checks if the requesting user has a 'Staff' role.
     */
    function isStaff() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_staff/$(request.auth.uid));
    }

    /**
     * Checks if the user is either Staff or Admin.
     */
    function isStaffOrAdmin() {
      return isStaff() || isAdmin();
    }
    
    /**
     * Checks if the user has any authorized role (Doctor, Staff, or Admin).
     */
    function isAuthorizedUser() {
      return isDoctor() || isStaffOrAdmin();
    }

    /**
     * On create, validates that a subcollection document's internal `patientId` field
     * matches the `patientId` from the document path.
     */
    function isCreatingSubDocConsistent(patientId) {
      return request.resource.data.patientId == patientId;
    }

    /**
     * On update, enforces that the `patientId` field in a subcollection document is immutable.
     * This prevents a document from being moved between patients.
     */
    function isPatientIdImmutable() {
      return request.resource.data.patientId == resource.data.patientId;
    }

    // --------------------------------------------------------------------
    // Role Collections
    // --------------------------------------------------------------------

    match /roles_admin/{userId} {
      // Admin roles must be assigned via a trusted backend, not from the client.
      allow read, write: if false;
    }
    match /roles_doctor/{userId} {
      // Allow a user to create their own 'doctor' role document upon registration.
      // Disallow any other client-side access.
      allow create: if isOwner(userId);
      allow read, update, delete: if false;
    }
    match /roles_staff/{userId} {
      // Allow a user to create their own 'staff' role document upon registration.
      // Disallow any other client-side access.
      allow create: if isOwner(userId);
      allow read, update, delete: if false;
    }

    // --------------------------------------------------------------------
    // Top-Level Collections
    // --------------------------------------------------------------------

    /**
     * @description Manages patient records. Only Staff and Admins can manage this collection.
     * This directly addresses the user request to be able to add and delete patients.
     * Deletion is restricted to Admins for safety.
     * @path /patients/{patientId}
     * @allow (create): An authenticated Staff or Admin user adds a new patient.
     * @deny (create): A Doctor attempts to add a new patient.
     * @allow (delete): An Admin deletes a patient record.
     * @deny (delete): A Staff member attempts to delete a patient record.
     * @principle Role-Based Access: Enforces strict role-based permissions for creating,
     * reading, and deleting sensitive patient data.
     */
    match /patients/{patientId} {
      allow get, list: if isStaffOrAdmin();
      allow create: if isStaffOrAdmin() && request.resource.data.id == patientId;
      allow update: if isStaffOrAdmin() && isExistingDoc();
      allow delete: if isStaffOrAdmin() && isExistingDoc();

      // ------------------------------------------------------------------
      // Patient Sub-Collections
      // ------------------------------------------------------------------
      
      /**
       * @description Manages patient appointments. Staff/Admins have general access, while a
       * Doctor can only access appointments they are specifically assigned to.
       * @path /patients/{patientId}/appointments/{appointmentId}
       * @allow (get): A Doctor reads an appointment where `resource.data.doctorId` matches their UID.
       * @deny (get): A Doctor attempts to read an appointment assigned to another doctor.
       * @deny (list): A Doctor attempts to list all appointments for a patient (access is per-document).
       * @principle Granular Access: Uses a denormalized `doctorId` field to grant access to a
       * specific document without granting access to the entire patient record.
       */
      match /appointments/{appointmentId} {
        allow get: if (isDoctor() && isOwner(resource.data.doctorId)) || isStaffOrAdmin();
        allow list: if isStaffOrAdmin();
        allow create: if isStaffOrAdmin() && isCreatingSubDocConsistent(patientId);
        allow update: if ((isDoctor() && isOwner(resource.data.doctorId)) || isStaffOrAdmin()) && isExistingDoc() && isPatientIdImmutable();
        allow delete: if isStaffOrAdmin() && isExistingDoc();
      }

      /**
       * @description Manages sensitive medical records. Staff/Admins have general access, while a
       * Doctor can only access records they are associated with. Deletion is restricted to Admins.
       * @path /patients/{patientId}/medicalRecords/{medicalRecordId}
       * @allow (update): A Doctor updates a record where `resource.data.doctorId` is their UID.
       * @deny (delete): A Staff member attempts to delete a medical record.
       * @principle Granular Access: Enforces document-level access for doctors based on a
       * denormalized `doctorId`, protecting patient privacy.
       */
      match /medicalRecords/{medicalRecordId} {
        allow get: if (isDoctor() && isOwner(resource.data.doctorId)) || isStaffOrAdmin();
        allow list: if isStaffOrAdmin();
        allow create: if isStaffOrAdmin() && isCreatingSubDocConsistent(patientId);
        allow update: if ((isDoctor() && isOwner(resource.data.doctorId)) || isStaffOrAdmin()) && isExistingDoc() && isPatientIdImmutable();
        allow delete: if isAdmin() && isExistingDoc();
      }

      /**
       * @description Manages patient medication prescriptions. General access is limited to
       * Staff and Admins to ensure proper oversight.
       * @path /patients/{patientId}/patientMedications/{patientMedicationId}
       * @allow (create): A Staff member prescribes a new medication for a patient.
       * @deny (create): A Doctor attempts to add a prescription directly.
       * @principle Role-Based Access: Restricts management of prescriptions to roles with
       * administrative or general patient care responsibilities.
       */
      match /patientMedications/{patientMedicationId} {
        allow get, list: if isStaffOrAdmin();
        allow create: if isStaffOrAdmin() && isCreatingSubDocConsistent(patientId);
        allow update: if isStaffOrAdmin() && isExistingDoc() && isPatientIdImmutable();
        allow delete: if isStaffOrAdmin() && isExistingDoc();
      }

      /**
       * @description Tracks a patient's progress through care workflows. Staff/Admins have
       * general access, while Doctors can only manage stages they are assigned to.
       * @path /patients/{patientId}/patientWorkflows/{patientWorkflowId}
       * @allow (get): A Doctor reads a workflow where `resource.data.assignedToDoctorId` matches their UID.
       * @deny (get): A Doctor attempts to read a workflow stage they are not assigned to.
       * @principle Granular Access: Uses a denormalized `assignedToDoctorId` to give specific
       * doctors write-access to parts of a patient's workflow.
       */
      match /patientWorkflows/{patientWorkflowId} {
        allow get: if (isDoctor() && isOwner(resource.data.assignedToDoctorId)) || isStaffOrAdmin();
        allow list: if isStaffOrAdmin();
        allow create: if isStaffOrAdmin() && isCreatingSubDocConsistent(patientId);
        allow update: if ((isDoctor() && isOwner(resource.data.assignedToDoctorId)) || isStaffOrAdmin()) && isExistingDoc() && isPatientIdImmutable();
        allow delete: if isAdmin() && isExistingDoc();
      }
    }

    /**
     * @description Manages doctor profiles. Any authenticated user can view doctor profiles.
     * A doctor can create and manage their own profile, while Admins can manage any profile.
     * @path /doctors/{doctorId}
     * @allow (update): A Doctor with UID 'user123' updates their own profile at `/doctors/user123`.
     * @deny (update): A Doctor with UID 'user123' attempts to update a profile at `/doctors/user456`.
     * @allow (delete): An Admin deletes a doctor's profile.
     * @deny (delete): A Doctor attempts to delete their own profile.
     * @principle Document Ownership and Admin Override: Combines user ownership for self-service
     * with an admin escape hatch for system management.
     */
    match /doctors/{doctorId} {
      allow get, list: if isSignedIn();
      allow create: if (isOwner(doctorId) && isDoctor()) || isAdmin();
      allow update: if ((isOwner(doctorId) && isDoctor()) || isAdmin()) && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description A global catalog of available medications. Readable by all authorized
     * personnel (Doctors, Staff, Admins), but writable only by Admins.
     * @path /medications/{medicationId}
     * @allow (list): Any authorized user lists all available medications.
     * @deny (create): A Staff member or Doctor attempts to add a new medication to the catalog.
     * @principle Read-Only Catalog: Allows broad read access for reference data while
     * strictly controlling modifications to maintain data integrity.
     */
    match /medications/{medicationId} {
      allow get, list: if isAuthorizedUser();
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description A global catalog of defined workflow stages. Readable by all authorized
     * personnel, but writable only by Admins.
     * @path /workflowStages/{workflowStageId}
     * @allow (get): A Staff member reads the details of a workflow stage.
     * @deny (update): A Doctor attempts to modify a workflow stage definition.
     * @principle Read-Only Catalog: Ensures that foundational system data like workflow
     * definitions are consistent and can only be changed by administrators.
     */
    match /workflowStages/{workflowStageId} {
      allow get, list: if isAuthorizedUser();
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }
  }
}
